class Solution {
    public int longestPalindrome(String s) {
        HashMap<Character, Integer> charCountMap = new HashMap<>();
        int pallindromeLength = 0;
        Boolean bool = false;
        // best case scenario , when string length is 1 , largest pallindrome is 1
        // Assuming string is non-empty
        if(s.length() == 1){
            return 1;
        }
        for(int i = 0 ; i < s.length(); i++){
            char temp = s.charAt(i);
            
            if(!charCountMap.containsKey(temp)){
                charCountMap.put(temp , 1); // First occurence of the character in the string
            }
            else{
                charCountMap.put(temp , (charCountMap.get(temp))+1); // increment the count by 1 if char is already present
            }
            
        }
        
        for(Integer i : charCountMap.values() ){
            
            if(i % 2 == 0){
                pallindromeLength = pallindromeLength + i; 
            }
            else{
                pallindromeLength = pallindromeLength + (i-1);
                bool = true;
            }
            
        }
           if(bool)
               return pallindromeLength+1;
            else
                return pallindromeLength;
        
    }
}

// Time Complexity - O(n)+O(n) = O(n) , Space Complexity - O(n)
// get the count of each character in the string and store it in a hashmap
// only 1 character can have odd number of occur
